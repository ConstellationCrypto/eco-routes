"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformAddresses = exports.saveDeploySalts = exports.addJsonAddress = exports.mergeAddresses = exports.getJsonFromFile = exports.createFile = exports.saltPath = exports.saltFileName = exports.csvFilePath = exports.tsFilePath = exports.jsonFilePath = exports.jsonFileName = exports.PRE_SUFFIX = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const lodash_1 = require("lodash");
exports.PRE_SUFFIX = '-pre';
exports.jsonFileName = 'deployAddresses.json';
exports.jsonFilePath = path.join(__dirname, `../../build/${exports.jsonFileName}`);
exports.tsFilePath = path.join(__dirname, '../../build/src/index.ts');
exports.csvFilePath = path.join(__dirname, '../../build/deployAddresses.csv');
exports.saltFileName = 'salt.json';
exports.saltPath = path.join(__dirname, `../../build/${exports.saltFileName}`);
function createFile(path = exports.jsonFilePath) {
    if (fs.existsSync(path)) {
        console.log('Addresses file already exists: ', path);
    }
    else {
        console.log('Creating addresses file: ', path);
        fs.writeFileSync(path, JSON.stringify({}), 'utf8');
    }
}
exports.createFile = createFile;
function getJsonFromFile(path = exports.jsonFilePath) {
    if (fs.existsSync(path)) {
        const fileContent = fs.readFileSync(path, 'utf8');
        return JSON.parse(fileContent);
    }
    else {
        createFile(path);
        return getJsonFromFile(path);
    }
}
exports.getJsonFromFile = getJsonFromFile;
function mergeAddresses(ads, path = exports.jsonFilePath) {
    const addresses = getJsonFromFile(path);
    fs.writeFileSync(path, JSON.stringify((0, lodash_1.merge)(addresses, ads)), 'utf8');
}
exports.mergeAddresses = mergeAddresses;
/**
 * Adds a new address to the address json file
 * @param deployNetwork the network of the deployed contract
 * @param key the network id
 * @param value the deployed contract address
 */
function addJsonAddress(deployNetwork, key, value) {
    const addresses = getJsonFromFile();
    const ck = deployNetwork.chainId.toString();
    const chainKey = deployNetwork.pre ? ck + exports.PRE_SUFFIX : ck;
    addresses[chainKey] = addresses[chainKey] || {};
    addresses[chainKey][key] = value;
    fs.writeFileSync(exports.jsonFilePath, JSON.stringify(addresses), 'utf8');
}
exports.addJsonAddress = addJsonAddress;
function saveDeploySalts(salts) {
    createFile(exports.saltPath);
    fs.writeFileSync(exports.saltPath, JSON.stringify(salts), 'utf8');
}
exports.saveDeploySalts = saveDeploySalts;
/**
 * Transforms the addresses json file into a typescript file
 * with the correct imports, exports, and types.
 */
function transformAddresses() {
    console.log('Transforming addresses into typescript index.ts file');
    const name = 'EcoProtocolAddresses';
    const addresses = JSON.parse(fs.readFileSync(exports.jsonFilePath, 'utf-8'));
    const importsExports = `export * from './abi'\nexport * from './utils'\n`;
    const types = `
// Viem Hex like type
type Hex = \`0x\${string}\`

/**
 * The eco protocol chain configuration type. Represents
 * all the deployed contracts on a chain.
 * 
 * @packageDocumentation
 * @module index
 */
export type EcoChainConfig = {
  Prover?: Hex
  IntentSource: Hex
  Inbox: Hex
  HyperProver: Hex
}

/**
 * The chain ids for the eco protocol
 * 
 * @packageDocumentation
 * @module index
 */
export type EcoChainIds = ${formatAddressTypes(addresses)}\n\n`;
    const comments = `/**
 * This file contains the addresses of the contracts deployed on the EcoProtocol network
 * for the current npm package release. The addresses are generated by the deploy script.
 * 
 * @packageDocumentation
 * @module index
*/
`;
    const outputContent = importsExports +
        types +
        comments +
        `export const ${name}: Record<EcoChainIds, EcoChainConfig> = \n${formatObjectWithoutQuotes(addresses, 0, true)} as const\n`;
    fs.writeFileSync(exports.tsFilePath, outputContent, 'utf-8');
}
exports.transformAddresses = transformAddresses;
// This function formats an object with quotes around the keys and indents per level by 2 spaces
function formatAddressTypes(obj) {
    return Object.keys(obj)
        .map((key) => `"${key}"`)
        .join(' | ');
}
// This function formats an object without quotes around the keys and indents per level by 2 spaces
function formatObjectWithoutQuotes(obj, indentLevel = 0, rootLevel = false) {
    const indent = ' '.repeat(indentLevel * 2); // 2 spaces per level
    const nestedIndent = ' '.repeat((indentLevel + 2) * 2);
    const formatValue = (value) => {
        if (typeof value === 'object' && value !== null)
            return formatObjectWithoutQuotes(value, indentLevel + 1); // Recursive with increased indent
        return JSON.stringify(value); // For numbers, arrays, etc.
    };
    const entries = Object.entries(obj)
        .map(([key, value]) => {
        return `${nestedIndent}"${key}": ${formatValue(value)}`;
    })
        .join(',\n');
    const frontIndent = rootLevel ? '  ' : '';
    return `${frontIndent}{\n${entries}\n${indent}  }`;
}
